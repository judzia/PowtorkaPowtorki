name: Unit tests, TODOs to issues and linting

# Określamy, kiedy pipeline ma się uruchomić
on:
  push:
    branches:
      - master  # Uruchomi się przy pushu na gałąź master
  pull_request:
    branches:
      - master  # Uruchomi się przy pull requestach na gałąź master

permissions: read-all  # Ustawienia uprawnień, które umożliwiają dostęp do wszystkich zasobów repozytorium

jobs:
  # Job 1: Uruchomienie testów jednostkowych z pokryciem
  test:
    runs-on: ubuntu-latest  # Uruchomi się na systemie Ubuntu

    steps:
      # 1. Sprawdzamy kod z repozytorium
      - uses: actions/checkout@v4

      # 2. Caching dla zależności Pythona, aby przyspieszyć kolejne uruchomienia pipeline
      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip  # Określamy ścieżkę, gdzie zapisujemy zależności
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}  # Klucz cache oparty na pliku requirements.txt
          restore-keys: |
            ${{ runner.os }}-pip-  # Zastosowanie zapasowego klucza w przypadku braku dopasowania

      # 3. Instalowanie Pythona (wersja 3.12 w tym przypadku)
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      # 4. Instalowanie zależności (np. coverage do raportowania pokrycia kodu)
      - name: "Install dependencies"
        run: |
          python -m pip install --upgrade pip  # Aktualizujemy pip
          pip install coverage  # Instalujemy paczkę coverage

      # 5. Uruchamiamy testy jednostkowe i generujemy raport pokrycia
      - name: "Run tests with coverage"
        run: |
          coverage run -m unittest discover test  # Uruchamiamy testy jednostkowe
          coverage report  # Raport w terminalu
          coverage html  # Raport w formacie HTML

  # Job 2: Lintowanie kodu
  lint:
    needs: test  # Job lintowania uruchomi się po zakończeniu testów
    runs-on: ubuntu-latest  # Uruchomi się na systemie Ubuntu

    permissions:
      contents: read  # Pozwalamy na odczyt zawartości repozytorium
      packages: read  # Dostęp do pakietów
      statuses: write  # Pozwalamy na zapisywanie statusów

    steps:
      # 1. Sprawdzamy kod z repozytorium
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Pobieramy pełną historię commitów

      # 2. Formatowanie plików YML przy użyciu Prettiera
      - name: Prettier format
        run: npx prettier --write .github/workflows/**/*.yml  # Formatujemy pliki .yml

      # 3. Uruchamiamy SuperLinter (sprawdzanie poprawności kodu)
      - name: Super-Linter
        uses: super-linter/super-linter/slim@v7.1.0  # Używamy wersji Slim SuperLintera
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Token do komunikacji z GitHub
          VALIDATE_PYTHON_RUFF: true  # Włączamy walidację dla Pythona (w tym przypadku z linterem Ruff)

  # Job 3: Tworzenie Issues z TODO w kodzie
  todo-to-issue:
    runs-on: ubuntu-latest  # Uruchomi się na systemie Ubuntu

    permissions:
      issues: write  # Pozwalamy na tworzenie i zarządzanie Issues
      contents: write  # Pozwalamy na zapisywanie zmian w repozytorium

    steps:
      # 1. Sprawdzamy kod z repozytorium
      - uses: actions/checkout@v4

      # 2. Uruchamiamy akcję do zamiany TODO na Issues w GitHub
      - name: "TODO to Issue"
        uses: "alstr/todo-to-issue-action@v5"
        with:
          INSERT_ISSUE_URLS: "true"  # Dodajemy linki do Issues w miejscach TODO w kodzie
          CLOSE_ISSUES: "true"  # Zamykamy Issues po ich utworzeniu
          AUTO_ASSIGN: "true"  # Automatycznie przypisujemy zadania do autora

      # 3. Ustawiamy globalnie użytkownika Git, aby commitować zmiany
      - name: Set Git user
        run: |
          git config --global user.name "github-actions[bot]"  # Ustawiamy nazwę użytkownika na github-actions[bot]
          git config --global user.email "github-actions[bot]@users.noreply.github.com"  # Ustawiamy e-mail na github-actions[bot]@users.noreply.github.com

      # 4. Sprawdzamy, czy są zmiany do commitowania, a jeśli tak, commitujemy i pushujemy
      - name: Commit and Push Changes
        run: |
          git add -A  # Dodajemy wszystkie zmiany do commita
          if [[ $(git status --porcelain) ]]; then
            git commit -m "Automatically added GitHub issue links to TODOs"  # Komentujemy commit
            git push origin master  # Pushujemy zmiany na master
          else
            echo "No changes to commit"  # Jeśli nie ma zmian, wypisujemy komunikat
